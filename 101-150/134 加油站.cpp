#include<iostream>
#include<vector>
#include<numeric>
using namespace std;


//134 加油站

/*
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
说明:
如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。
输入:
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]
输出: 3
*/

//我之前的错误代码问题就出在起始站点的选取，我是找第一个油量大于消耗的点就直接结束了
//但是不一定当前油量高就一定能走完，因为从趋势上来考虑
//谁也不知道gas-cost的差值是怎样变换的
//要想确定真的可以走完全程
//一定要整个遍历去保证最终剩余油量是正的，否则就要更换起始站点

//这里要抽象的去理解问题
//首先可以确定的一点就是，我当然要取第一个gas值大于cost值的点为起点，为什么呢？因为如果gas值小于cost值，是没法走到下一站的
//其次，要保证总油量大于总消耗，在此前提下，想象一下，当我开始遍历数组，而gas[0]<cost[0]时应该怎么办？当然是跳过看下一个，也就是说我在遍历过程中是动态的选择起点的
//还有一点就是，一旦有跳过，就说明在这一个站点费油太多了，把原来剩余油量用完也不够
//以示例1为例：gas  = [1,2,3,4,5] cost = [3,4,5,1,2]
//注意，我这里的前提是总油量大于总消耗！！！！！
//前3个站点都是gas值小于cost，说明这三个站点的总油量小于走这三短路的消耗量，而总的油量大于总消耗，后面肯定有某个点的油量是大于消耗的，那么从这个站点出发，可以到达数组最末端（其实是到达数组头），然后继续通过前面这几个站点，走完全程，这个站点就是起始站点
//为什么肯定能走完一圈：假设总油量为a,总消耗为b，其中前一段总油量为c，消耗量为d，我们知道有c<d，那么肯定有a-c>b-d，也就是说后面这段路的总油量绝对是大于总消耗量的
//这就说明，从该点出发是可以重新回到数组头的，也就是我们之前说的第一站，这个时候我油箱的余油为a-c-(b-d)
//现在我在第一个站点，要知道，没有余油的情况下，无论从前几个站点的哪个站点出发都是无法到达起始站点的，但有余油时就可以做到，假设从第二个站点到起始点总油量为e，总消耗为f,e<f
//那么第一个站点有油c-e,消耗为d-f，加上前面的余油，到达第二站时的余油为a-c-(b-d)+c-e-(d-f)=a-b+(f-e)>0,以此类推，可以到达起始站点
//主要在于理解，代码很简单
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
	//总消耗大于总油量，返回-1
	if (accumulate(gas.begin(), gas.end(), 0)<accumulate(cost.begin(), cost.end(), 0))
		return -1;
	int start = 0;//记录当前起始站点
	int remain = 0;//记录当前剩余油量
	for (int i = 0; i<gas.size(); i++)
	{
		remain += (gas[i] - cost[i]);//更新剩余油量
		if (remain<0)
		{
			start = i + 1;//更新新的起始站点，因为前面的那个start不行
			remain = 0;//剩余油量归零，从新的start开始重新记录
		}

	}
	return start;
}
int main()
{
	vector<int> gas = { 1,2,3,4,5 };
	vector<int> cost = { 3,4,5,1,2 };
	int res = canCompleteCircuit(gas, cost);
}