#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

//60 第k个排列
//用换位来实现排列
/*
给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。
说明：
给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。
示例 1:
输入: n = 3, k = 3
输出: "213"
*/


/*思路：初始的排序总是数值从大到小 比如123 1234 等
//以1234为例，1打头的序列有6个（因为1后面有3个数，3的阶乘就是6）
//第7个就是2134，那第九个呢？第9个就是第7个再变两次
//2134 2143 2314 我现在考虑的是次高位怎么变
//次高位后面还有三个数，也就是说k每增加2，次高位就会改变一次（其实是2的阶乘）
//如果是第11个呢？2341 2413 
//观察第7个 第9个 第11个的后三位 分别是 134 314 413
//一个2，就是保存当前次高位，下一位数字前移，再把次高位的值放到空出来的位置
//两个2，就是保存当前次高位，后面两位数字前移，再把次高位的值放到空出来的位置
//这就是我做这个题的思路，随便画几下就能找到规律
*/

//用来计算阶乘
int getNum(int i)
{
	int count = 1;
	while (i > 0)
	{
		count *= i;
		i--;
	}
	return count;

}
string getPermutation(int n, int k) {
	string res;
	//首先将res初始为顺序排列1234...
	for (int i = 0; i<n; i++)
		res.push_back('1' + i);
	int digit = 0;//当前处理到的位，最高位为0
	k -= 1;
	//从第一个到第k个的变化，以1234为例
	//当此时k小于6时，最高位不变，只有后三位在变
	//但当k大于6时，最高位也要变，怎么变？将当前位置向前移动  k/后面位数阶乘 位，保存该值，将其余值向右平移再把这个值放在目前排列到的位置上，以此类推
	while (k>0 && digit<n)
	{
		int num = getNum(n - 1 - digit);
		if (k >= num)
		{
			//这里就是控制数组元素移动的地方
			int i = digit + k / num;
			char temp = res[i];//保存该值，进行平移，将该值放在空出来的地方
			for (int j = i; j>digit; j--)
				res[j] = res[j - 1];
			res[digit] = temp;
			k -= k / num*num;
		}
		digit++;
	}
	return res;
}

int main()
{
	string s = getPermutation(4, 16);
	return 0;
}