#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;

// 91 解码方法

/*
一条包含字母 A-Z 的消息通过以下方式进行了编码：
'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。
示例 1:
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2:
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
*/

//用动态规划做
/*要理解编码数目这个概念，不同于在计算路径时使用动态规划，
* 这里不涉及+1的问题，如果只有一种选择，就继承前面的值，有两种选择时将两种选择叠加
* 1.如果当前位为0：
* 如果前一位不是1或2，则这个0无法和任何数组成字母，代表整个串无法构成编码
* 如果前一位是1或者2，则说明前一位和当前位能组成字母，这时候能构成的编码数目是和前前位相同的，即：dp[i] = dp[i-2]
* 2.如果当前位不为0：
* 如果前一位和当前位能组成字母，则当前位的构成编码数目应该为前一位和前前位之和，即：dp[i] = dp[i-1] + dp[i-2]，当然要考虑当前位是否符合i>=2?
* 如果前一位和当前位不能组成字母，则当前位单独组成字母，即dp[i] = dp[i-1]
*/
int numDecodings(string s)
{
	if (s.empty() || s[0] == '0')
		return 0;
	int len = s.length();
	vector<int> dp(len, 0);
	dp[0] = s[0] == '0' ? 0 : 1;
	for (int i = 1; i<len; i++)
	{
		if (s[i] == '0')
		{
			if (i == 1 && (s[i - 1] == '1' || s[i - 1] == '2'))
				dp[i] = 1;
			else if (i >= 2 && (s[i - 1] == '1' || s[i - 1] == '2'))
				dp[i] = dp[i - 2];
			else
				return 0;
		}
		else
		{
			//当满足下列条件时,当前字符可以和前一个构成字符串，此时dp[i] = dp[i-1] + dp[i-2](i>1时)
			if (s[i - 1] == '1' || (s[i - 1] == '2'&&s[i] <= '6'))
			{
				if (i == 1)
					dp[i] = dp[i - 1] + 1;
				if (i >= 2)
					dp[i] += dp[i - 2] + dp[i - 1];
			}
			else
				dp[i] = dp[i - 1];//前一位不能和当前位组成字母，当前位单独组成字母
		}
	}
	return dp[len - 1];
}
int main()
{
	string s = "12";
	int res = numDecodings(s);
	return 0;
}