#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

//174 地下城游戏
//这道题用动态规划来解决

/*
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
为了尽快到达公主，骑士决定每次只向右或向下移动一步。
*/
/*
首先这道题得调换一下思路，因为要算存活的最小初始值，要从右下出发来进行计算，骑士救公主的条件是在到达右下角时健康点数大于0
那么就要设置到达此处时的值为max(1,1-dungeon[row-1][col-1]),因为有可能最右下是个血包，此时只需要健康值是1就行，否则健康值得是1+此处的损失，其余位置也是同理
与1比较的意义在于无论如何健康值不能为负，就算前面有个100的血包，总不能带着-80的健康值走到这个点加血吧
然后遍历数组，先设置最后一行和最后一列的值，再逐步填满数组，每次取下方和右方的最小值减去(i,j)下标处的消耗（因为消耗是有符号的，为负，减就是加）
*/

int calculateMinimumHP(vector<vector<int>>& dungeon) {
	if (dungeon.size() == 0 || dungeon[0].size() == 0)
		return 0;
	int row = dungeon.size();
	int col = dungeon[0].size();
	vector<vector<int>> dp(row, vector<int>(col, 0));
	dp[row - 1][col - 1] = max(1, 1 - dungeon[row - 1][col - 1]);
	//初始化最后一行
	for (int i = col - 2; i >= 0; i--)
		//右侧的值减去当前的消耗，这个值和1的最大值就是dp[row-1][i]处的值
		dp[row - 1][i] = max(1, dp[row - 1][i + 1] - dungeon[row - 1][i]);
	//初始化最后一列
	for (int i = row - 2; i >= 0; i--)
		//下侧的值减去当前的消耗，这个值和1的最大值就是dp[i][col-1]处的值
		dp[i][col - 1] = max(1, dp[i + 1][col - 1] - dungeon[i][col - 1]);
	for (int i = row - 2; i >= 0; i--)
	{
		for (int j = col - 2; j >= 0; j--)
		{
			//取下侧和右侧的较小值减去当前消耗，与1比较
			dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);;
		}
	}
	//最终(0,0)处保存的就是想要的结果
	return dp[0][0];
}